## 1  嵌入式系统基础知识

#### 1.1  嵌入式系统的定义 

  嵌入式系统是指以应用为中心，以计算机技术为基础，软件硬件可剪裁，适应应用系统，对功能、可靠性、成本、体积、功耗严格要求的计算机系统

#### 1.2  嵌入式系统三要素 

* 嵌入性
* 专用性
* 计算机系统

#### 1.3  嵌入式系统的分层以及各自作用 

|  **层次** |                                           **作用**                                           |
|:----------:|:--------------------------------------------------------------------------------------------:|
| 应用软件层 |   用来实现被控对象的控制功能，由所开发的应用程序组成，面向被控制对象和用户，一般有人机界面   |
| 系统软件层 |                 包括操作系统、文件系统等，是嵌入式应用软件的基础和开发平台。                 |
|   中间层   | 位于硬件层和软件层之间，将系统上层软件与底层软件分离开来。包括大部分与硬件联系紧密的软件模块 |
| 硬件层 |嵌入式微处理器（嵌入式系统的核心部分）、存储器、通用设备接口和 I/O 口（用于连接其他外设）|

#### 1.4  RTOS 实时操作系统概念 

* 概念：实时操作系统是指能够在指定或者确定的时间内完成系统功能和对外部或内部、同步或异步时间做出响应的系统，系统能够处理和存储控制系统所需的大量数据。 
* 与非实时操作系统的区别：实时操作系统要求系统中的任务不仅要执行结果正确，还要在一定的时间约束内完成。仅有两个条件都满足才算做执行正确。非实时系统没有时间约束。
* 实例：VxWorks，Windows CE，嵌入式 Linux：uCLinux、RT-Linux 等

#### 1.5 嵌入式系统的特点 

* 可裁剪性
* 强实时性
* 统一的接口
* 强稳定性
* 固化的代码
* 更好的硬件适应性
* 软件开发需要专门的开发工具和开发环境
* 要求开发、设计人员有较高的硬件技能

## 2  ARM 技术概述和 S3C2410 简介

#### 2.1 精简指令集（RISC）与 CISC 的区别 

| __指标__ | **RSIC** | **CISC** |
| :--------: | :--------: | :--------: |
| 指令集   |一个周期执行一条指令，简单指令组成复杂操作，指令长度固定|指令长度不固定，执行需多个周期|
| 流水线   |流水线每周期前进一步|指令的执行需要调用微代码的一个微程序|
| 寄存器   |更多用于通用寄存器|用于专用寄存器|
|Load/Store结构|独立的 Load/Store 指令完成数据在寄存器内外的传输|处理器直接处理存储器数据|


#### 2.2 存储器大小端模式的区别 

* 大端：大端的数据存放格式是指将最高有效字节置于最低位地址 
![[Pasted image 20230208201816.png|200]]
* 小端：小端的数据存放格式是指将最高有效字节于最高位地址
 ![[Pasted image 20230208201837.png|200]]

#### 2.3 处理器的 7 种模式 

| **处理器模式** |                **说明**                |               **备注**               |
|:--------------:|:--------------------------------------:|:------------------------------------:|
|  用户（usr）   |            正常程序执行模式            |          不可切换至其他模式          |
|  系统 （sys）  |         运行操作系统的特权任务         | 与用户模式类似，但拥有切换模式的特权 |
| 快中断（fiq）  |       支持高速数据传输及通道处理       |       fiq 异常响应时进入此模式       |
|  中断（irq）   |            用于通用中断处理            |       irq 响应异常时进入此模式       |
|  管理（svc）   |            操作系统保护模式            |  系统复位和软件中断响应时进入此模式  |
|  中止（abt）   | 预期终止时进入，用于虚拟存储和存储保护 |        在 ARM7TDMI 没有大用处        |
| 未定义（und）  |        支持硬件协处理的软件仿真        |      未定义指令异常时进入此模式      |

> 除 ***用户模式（usr 模式）*** 外均为 ***特权模式***

>除 ***用户模式*** 与 ***系统模式*** 外均为 ***异常模式***

#### 2.4  流水线 
流水线是指程序执行多条指令重叠时的一种标准并行处理实现技术。各种部件同时处理是针对不同的指令而言的，他们可以同时为多条指令的不同部分进行工作，以提高各部件的利用率与指令的平均执行速度。

> 流水线分类 
>> 三级流水线 ARM 组织：**取指令→译码→执行；**
>> 五级流水线 ARM 组织：**取指令→译码→执行→缓冲/数据→回写；**
>> 六级流水线 ARM 组织：**取指令→发射→译码→执行→存储→回写。**

#### 2.4  实验二：存储器访问实验 
>编写程序，首先将 SDRAM 中 0x3300_0000 到 0x3300_FFFF 的内存空间中数据置为 0x55，然后将 Flash 中起始地址为 0x0000_0000 到 0x0000_FFFF 的数据拷贝到 SDRAM 中 0x3300_0000 到 0x3300_FFFF 的空间中。

```C
#include "def.h"
#include "option.h"
#include "2440addr.h"    
#include "2440lib.h"
#include "2440slib.h"  
#define UINT32T unsigned int  

int main(int argc,char **argv)
{
    UINT32T data;
    UINT32T *pt;    
    UINT32T *bt;
    bt=(UINT32T *)(0x33000000);//起始地址
    //给SDRAM中0x33000000到0x3300FFFF数值赋为0x55
    while((UINT32T)bt<=(0x3300FFFF))
    {
    *bt=0x55; //将0x55赋给指向SDRAM中的指针所在位置
    bt++;
    }
    pt=(UINT32T *)(0x00000000);//重定义pt起始地址
    bt=(UINT32T *)(0x33000000);//重定义bt的起始地址
    while((UINT32T)pt<=(0x0000FFFF))
    {
        data=*pt;//pt指向地址中的值赋给data
        *bt=data;//data赋给指向SDRAM中的指针bt指向的地址
        pt++;
        bt++;
    }
    while(1);
}
```

## 3  ARM 的指令系统与汇编语言（***不考***）

## 4  S3C2410 的存储器

#### 4.1  ARM 的启动架构 
	（1）从Nor Flash启动
		引导代码、操作系统和应用代码共存于同一块Nor Flash。上电后引导代码先在Nor Flash中执行，然后把操作系统和应用代码加载到速度更高的SDRAM中运行（或者Nor Flash中执行引导代码和操作系统，只把应用代码加载到SDRAM）。
	（2）Nor Flash和Nand Flash配合使用
		系统上电，引导代码在Nor Flash中执行，把Nand Flash中的操作系统和应用代码加载到SDRAM中执行。该构是当前嵌入式系统中运用广泛的启动架构之一。

|           **启动方式**           |               **图解**               | **优点** | **缺点** |
|:--------------------------------:|:------------------------------------:|:--------:|:--------:|
|        从 Nor Flash 启动         | ![[Pasted image 20230208205130.png]] |充分利用Nor Flash芯片内执行的特点，提高系统性能|操作系统和应用代码的体量增大，就要更昂贵的Nor Flash支持 |
| Nor Flash 和 Nand Flash 配合使用 | ![[Pasted image 20230208205152.png]] |节约成本，减少采用更昂贵 Nor Flash 的开销|系统性能相对较低|

#### 4.2 RAM，SRAM，DRAM 与 SDRAM 

* RAM：随机存取存储器
* SRAM：静态随机存储器，**读写比 DRAM 更快且功耗更大，不需要周期性刷新**
* DRAM：动态随机存储器，**集成度和容量可以更大，需要周期性刷新**
* SDRAM：同步动态存储器，*需要周期性刷新*， **在系统中的作用为**：
	* 作为程序的运行空间，数据及堆栈区
	* 完成初始化操作后代码一般调入 SDRAM 中运行，以提高运行速度

## 5  S3C2410 的 GPIO 编程 

#### 5.1  控制、数据、上拉寄存器如何配置，内部参数如何更改
*  控制寄存器 GPACON~GPHCON，GPnCON 定义每个引脚的功能
*  数据寄存器 GPADAT~GPHDAT，如果端口被配置成了输出端口，可以向 GPnDAT 的相应位写数据；如果端口被配置成了输入端口，可以从 GPnDAT 的相应位读取数据。
* 上拉寄存器 GPBUP~GPHUP，决定了每个端口组的上拉电阻是否允许上拉。若某一位为 0，则允许上拉；（在这种情况下，无论端口处于何种状态，均允许上拉），若某一位不为 0，则不允许上拉。

#### 5.2  实验一：GPIO 编程
>编写程序，控制实验平台的发光二极管 LED1, LED2, LED3, LED4，使它们有规律的点亮和熄灭，具体顺序如下：
全亮->LED4 单独亮->LED2 单独亮->LED3 单独亮->LED1 单独亮->LED4 单独灭->LED2 单独灭->LED3 单独灭->LED1 单独灭->全灭，如此反复，发光二极管的各个变化间隔约 1 秒（通过循环等待实现）
![[Pasted image 20230313200628.png|275]]
![[Pasted image 20230313200649.png|425]]

```C
#include "def.h"
#include "option.h"
#include "2440addr.h"    
#include "2440lib.h"
#include "2440slib.h"  

/**
@brief 数制转换很烦人，此外，本题目不需要定义GPnCON, GPnDAT, GPnUP的入口地址，头文件中已有定义过
*/
/*本实验用到寄存器的参数表从PPT171页开始*/
int main(int argc, char **argv)
{
   int i;  // 计时器用
   // GPBCON 共 22 位 - > [21:0]
   rGPBCON = 0x15400; // 00 0001 0101 0100 0000 0000 
             //位号 GPB   10 0908 0706 0504 0302 0100    
             //均设置成01输出模式           
   while (1)
   {
	   // GPBDAT 共 11 位 - > [10:0]
      rGPBDAT = 0x0;         //全亮 000 0000 0000 
      for(i=0;i<50000;i++);  //延时        
      rGPBDAT = 0x0E0;       //LED4 000 1110 0000 
      for(i=0;i<50000;i++);  
      rGPBDAT = 0x1B0;       //LED2 001 1011 0000 
      for(i=0;i<50000;i++);
      rGPBDAT = 0x160;       //LED3 001 0110 0000 
      for(i=0;i<50000;i++);
      rGPBDAT = 0x1C0;       //LED1 001 1100 0000 
      for(i=0;i<50000;i++);
      rGPBDAT = 0x100;       //LED123 001 0000 0000 
      for(i=0;i<50000;i++);
      rGPBDAT = 0x40;        //LED134 000 0100 0000
      for(i=0;i<50000;i++);
      rGPBDAT = 0x80;        //LED124 000 1000 0000
      for(i=0;i<50000;i++);
      rGPBDAT = 0x20;        //LED234 000 0010 0000
      for(i=0;i<50000;i++);
      rGPBDAT = 0x1E0;       //全灭
      for(i=0;i<50000;i++);
    }        
}
```

## 6  S3C2410 的定时器

#### 6.1 定时器结构 

|   **结构**   |                                                       **组成**                                                        |
|:------------:|:---------------------------------------------------------------------------------------------------------------------:|
|   时钟控制   |                                            预分频器 Prescaler；分频器 MUX                                             |
| 定时器主结构 | 初值计时器（TCNTBn）、减法计数器（TCNTn）、比较缓冲寄存器（TCMPBn+TCMPn）双缓冲、观察寄存器（TCNTOn）、控制逻辑等部分 |

![[Pasted image 20230211195820.png]]

#### 6.2 定时器工作过程 

* 手动装填初值（写 TCNTBn）$\Rightarrow$ 决定 PWM 频率
* 启动计数器（写 TCON）
* 计数结束（TCNTn=0），产生中断请求，可以自动装填初值继续计数

#### 6.3 PWM 输出原理 

* 寄存器 TCNTn（减法计数器）中的值减至与 TCMPBn（比较缓冲寄存器）相等时，TOUTn 的输出取反 
	* **TCMPBn** 的值决定 PWM 的不同**占空比**，**TCNTBn** 的值决定 PWM 的**频率**
	* 若得到**更高**的 PWM 占空比，则要**增加** TCMPBn 的值，反之减少
	* 若果使用反相器，则控制 PWM 的规律正好相反

#### 6.4 计数时钟和输出计算 

* **定时器输入时钟频率** $f_{\mathrm{Tclk}}$ ——计数时钟频率
  $f_{\mathrm{Tclk}}=分频值\times\frac{f_{\mathrm{pclk}}}{\mathrm{Prescaler}+1}$ 
	* $\mathrm{Prescaler}$ 预分频值\[0:255\]
	* 分频值：1/2, 1/4， 1/8， 1/16
* **PWM 输出时钟频率**：$\mathrm{PWM 输出时钟频率}=\frac{{f_\mathrm{Tclk}}}{\mathrm{TCNTBn}}$ 
* **PWM 输出信号占空比**：$\mathrm{PWM 输出信号占空比}=\frac{\mathrm{TCMPBn}}{\mathrm{TCNTBn}}$    

#### 6.5 定时器的使用方法 

* 定时器的初始化方法：
	* 写 TCFG0，设置计数时钟的预分频值
	* 写 TCFG1，选择各个定时器的分频值
	* 对 TCNTBn 和 TCMPBn 分别写入计数初值和比较初值
	* 写 TCON，设置自动重装初值、手动装载初值、反相输出
	* 重写 TCON，清除手动装载初值位，设置正相输出、启动计数
* 定时器停止运行的方法：
	* 写 TCON，禁止计数初值自动重装

#### 6.6  看门狗电路的作用 
* 大致功能：
	* 作为常规定时器使用，并且可以产生中断；
	* 作为看门狗定时器使用，定时时间到，他可以产生 128 个时钟周期的复位信号。
* 详细说明： 
	* 看门狗定时器控制寄存器 WTCON：通过该寄存器，可以使能/禁止看门狗、选择输入时钟源、使能/关闭中断、使能/关闭输出。
	* 看门狗定时器数据寄存器 WTDAT：该数据寄存器用于设置看门狗定时器的初值。在初始操作中，该值不会自动加载到定时器中，首次定时器初始值时 0x8000，以后该寄存器的值会被自动加载到 WTCNT 寄存器中。一般作为普通定时器使用。 

#### 6.7 实验三 PWM 实验

>编写程序，实现用定时器 T0 的输出 PWM，改变定时器 T0 的计数器寄存器实现不同波形。本实验平台的 PCLK 的频率为 50MHz，要求 PWM 波的输出频率和占空比分别为 (100Hz, 1/2)、（100Hz，1/3）、（200Hz，1/2）、（200Hz，1/3）等。
> ![[Pasted image 20230314111050.png|400]]

```C
#include "2440addr.h"    
#include "2440lib.h"
#include "2440slib.h"  
#define UINT32T unsigned int  

/**
定时器初始化流程
（1）写TCFG0，设置计数时钟的预分频值；
（2）写TCFG1，选择各个定时器的分频值；
（3）对TCNTBn和TCMPBn分别写入计数初值和比较初值；
（4）写TCON，设置计数初值自动重装、手动装载初值、设置反相输出；
（5）再写TCON，清除手动装载初值位、设置正相输出、启动计数。
*/
void main(int argc,char **argv)
{  
     // TOUT0使能，从这个口输出PWM波
     rGPBCON=rGPBCON & 0XFFFFF0|(1);  //查表PPT 172页
     //预分频39, 需要多少预分频值直接设置就行
     rTCFG0=39; //TCFG0-预分频配置寄存器 PPT 210页
     //分频1/16，00000000 0000 0000 0000 0000 0011 0000
     // TCFG1中MUX0段为0011，代表采用timer0且16分频
     rTCFG1=0x03; //TCFG1 DMA模式与分频选择寄存器 PPT 211页
     rTCNTB0=780; //输出频率100Hz, 计算看下面, TCNTBn-计数初值寄存器
     rTCMPB0=390; //占空比1/2 TCMPBn-比较缓冲寄存器
     // TCON的值为1111，TL0 - > 自动重装 TO0 - > 反相输出
     // TUP0 - > 手动装载初值 TR0 - > 启动timer0
     rTCON|=(1<<3)|(1<<2)|(1<<1)|(1<<0); // 查表PPT 212
     // TCON的值为1001，TL0 - > 自动重装 TO0 - > 正向输出
     // TUP0 - > 清除手动装载初值 TR0 - > 启动timer0     
     rTCON&=~((1<<2)|(1<<1));                
     while(1);  
}
```

* **确定 TCNTB0 和 TCMPB0 的过程**
	* 根据预分频和分频求出 $f_{\mathrm{Tclk}}=\frac{50 \times 10^6}{39+1} \times \frac{1}{16}=78125 \mathrm{Hz}$ 
	* 根据题目中要求的输出频率 100Hz 反推 TCNTB0：$\mathrm{TCNTB0=\frac{f_{Tclk}}{100}=\frac{78125}{100}\approx780}$ 
	* 根据题目中要求的占空比要求求出 TCMPB0 ：$\mathrm{TCMPB0={TCNTB0}\times{d}=780\times 0.5}=390$ 

## 7  串行通信接口

#### 7.1  数据格式（帧格式）

|  **类型**  | **长度** |     **说明**     |
|:----------:|:--------:|:----------------:|
|   起始位   |   1 位   |   规定为低电平   |
|   数据位   |  5~8 位  | 要传送的有效信息 |
| 奇偶校验位 |   1 位   |        ——        |
|   停止位   |  1~2 位  |   规定为高电平   |

![[Pasted image 20230211202101.png]]

#### 7.2  三种校验方式对比

|  **方式名称**  |                                                                        **原理**                                                                        |                                      **特点**                                       |
|:--------------:|:------------------------------------------------------------------------------------------------------------------------------------------------------:|:-----------------------------------------------------------------------------------:|
|   奇偶校验位   |                                     在传送的字符之外再传送一位奇/偶校验位。可采用奇校验（1 的个数为奇数）或偶校验                                      |                              容易漏判错误，且不能纠错                               |
|   累加和校验   | 发送方将所发送的数据块求和，并将“校验和”附加到数据末尾，接收方也对接收到的数据求和，并将结果与发送方的“校验和”进行比较。一致则传输正确。反之传输错误。 |                             无法检验出字节或位序的错误                              |
| 循环冗余码校验 |                            块看成一串二进制数，再除以特定的数，将余数作为校验码发送到接收方。接收方同样求余，以校验是否出错                            | 目前该算法已广泛运用于数据存储和数据通信，并形成国际规范，市面上已有诸多CRC软件算法 |                                                                                                                                                        |                                                                                     |

#### 7.3  RS-232C 的电气特性
* IA 电平，高电平为+3~+15V，低电平为-15~-3V
* 实际应用中，常采用±12V
* RS-232C 的数据线 TXD、RXD 使用负逻辑，高电平表示 0，低电平表示 1

#### 7.3 实验四： 串口编程
>编写程序，控制实验平台的 UART1（波特率 38400、1 位停止位、无校验位），接收 PC 机上 windows 自带的超级终端串口通信程序发送的字符，同时按照以下要求将相应的字符返回给 PC 机的超级终端串口通信程序显示。
>>如 PC 机发送“A”，则返回字符“1” 
>>如PC 机发送“B”，则返回字符“2”
>>如PC 机发送“C”，则返回字符“3”
>>如PC 机发送其他字符，则返回字符“4”

```C
#include "def.h"
#include "option.h"
#include "2440addr.h"    
#include "2440lib.h"
#include "2440slib.h"    
#define UINT32T unsigned int

// 函数声明
void uart1_init(void); //串口初始化函数
void uart_sendbyte(char data); //发送函数
char uart_getch(void); //接收字符

void main(int argc,char **argv)
{
    uart0_init(); //先初始化串口   
    while(1)
    {
        uart_getch(); //读取字符
        switch(rURXH0) 
        {
	        //接收A,发送1
            case 'A':uart_sendbyte('1');break; 
            //接收B,发送2
            case 'B':uart_sendbyte('2');break; 
            //接收C,发送3
            case 'C':uart_sendbyte('3');break; 
            //接收D,发送4
            default: uart_sendbyte('4');break; 
         }
    }
}

/**
@brief 串口初始化
*/
void uart1_init(void)                    
{
	rGPHCON=(rGPHCON&~(0xfff<<4))|(0xaaa<<4); // PPT 182
	//设置端口RX0~2、TX0~2, 用哪个开哪个就行，这个实验都开了也行
	//其中(rGPHCON&~(0xfff<<4))是将TXD0~2,RXD0~2均清零
	//之后在与(0xaaa<<4)进行或运算后对应位均为10，即RXD、TXD使能
    rGPHUP=rGPHUP|(0x7<<2);  //禁止GPH1~3上拉
    //只有GPIO为输入状态以及外部电路为oc门时需要上拉，其余情况均禁止
    rUFCON1=0x0; //禁止FIFO, UFCONn:FIFO控制寄存器, PPT 261 
    rUMCON1=0x0; //禁止AFC, UMCONn:MODEM控制寄存器, PPT 262
    // ULCONn:UART行控制寄存器 PPT 259    
    // 设置帧格式  ULCON1 < - 0 0 000 0 11
    // 0-保留位 0-正常模式 000-无校验 0-1个停止位 11-数据位8bit
    rULCON1=(rULCON1&~0xff)|((0x0<<6)|(0x0<<3)|(0x0<<2)|(0x3));
    // UCONn:UART控制寄存器 PPT 260
    // UCON1 < - 1 0 0 0 0 0 0 01 01
    // 1-ULK作比特率发生器 0-tx中断脉冲触发 0-接收超时中断不允许
    // 0-不产生接收错误中断 0-正常模式 0-正常模式发送
    // 01-发送模式为中断或查询模式 01-接受模式为中断或查询模式
    rUCON1=(rUCON1&~0x3ff)|((0x0<<10)|(0x0<<6)|(0x1<<2)|(0x1));
    // UBRDIVn:波特率控制寄存器 PPT 257
    rUBRDIV1=(int)(50000000/(16*38400))-1; //设置波特率38400  
}

/**
@brief 通过串口发送字符
@param data 待发送的字符
*/
void uart_sendbyte(char data)    
{
	// 在关闭FIFO的情况下，UTRSRTAT[1]=1 - > 发送缓冲为空，已发完
    while(!(rUTRSTAT1&0x02));  //判断是否发完
    // UTXHn:发送寄存器
    rUTXH1=data; // 将数据送入缓冲区
}

/**
@brief 从串口读取数据
*/
char uart_getch(void)                  
{
	// 在关闭FIFO的情况下，UTRSRTAT[0]=0 - > 接收缓冲为空，已收完
    while(!(rUTRSTAT1&0x01));  //不为空的时候读出
    // URXHn:接收寄存器
    return rURXH1; // 将数据提出缓冲区
}
```

## 8 A/D 转换

#### 8.1 A/D 转换的四个步骤

* **采样 -> 保持 -> 量化 -> 编码**
	* 采样/保持：由采样保持电路（S/H）完成；
	* 量化/编码：由 ADC 电路完成（ADC：AD 转换器）
* **采样**：将一个时间上**连续**变化的模拟量转化为时间上**断续**变化的模拟量（连续 -> 离散）
* **保持**：将采样得到的模拟量值保持下来，使之等于采样控制脉冲存在的最后瞬间的采样值。
* **量化**：是用基本的量化电平的个数来表示采样到模拟电压值。即把时间上离散而数值上连续的模拟量以一定的准确度变换为时间上、数值上都离散的具有标准量化级的等效数字值。（量化电平的大小取决于 A/D 变换器的字长）
* **编码**：是把已经量化的模拟数值 (它一定是量化电平的整数倍) 用二进制码、BCD 码或其它码来表示。

#### 8.2 香农采样定理

为了不失真地恢复模拟信号，采样频率应该大于等于模拟信号频谱中最高频率的 2 倍，即：$f_s ≥ 2f_{max}$ 

#### 8.3 A/D 转换控制程序的编制步骤

1. 设置 A/D 转换的时钟频率——取决于 ADCCON 寄存器的 PRSCVL 的值，计算式 $\mathrm{PRSCVL=\frac{PCLK}{freq} -1}$ 
2. 启动 A/D 转换：`rADCCON = 0x01;`
3. 检查转换是否结束：`while(rADCCON & 0x8000);`
4. 启动读允许功能：`rADCCON = 0x02;`
5. 读 A/D 转换数据：`uint i = rADCDAT0 & 0x3FF;`

#### 8.4 实验五 A/D 转换实验

>旋转电位器的位置，通过 S3C2440X 的 AD 转换器模拟通道 0，将电阻上的电压值转换成数字量，并将数字量数据换成十进制浮点数（小数点后 2 位），同时，十进制浮点数通过 UART0 发送至 PC 机的串口调试助手（波特率 115200、1 位停止位、无校验位、无硬件流控制）中显示。
>> 提示：数字量数据 usConData 换成十进制浮点数，并输出：
>> `usEndData=usConData*3.3000/0x3FF;`
>> `uart_printf (" %0.2f ", usEndData); `

```C
#include "def.h"
#include "option.h"
#include "2440addr.h"    
#include "2440lib.h"
#include "2440slib.h"  
#define UINT32T unsigned int  

/*******函数声明区*******/
void uart0_init(void); // 串口初始化函数
void uart_sendbyte(float data); // 发送字符函数
void AD_Init(unsigned char ch); // AD初始化函数
int Get_AD(unsigned char ch); // AD转换函数

/*******主函数*******/
void main(int argc, char **argv)
{
    uart0_init(); //初始化串口
    while(1)
    {                      
        int num; 
        float dat;
        AD_Init(0);    //初始化AD转换器  
        num = Get_AD(0);            //取AD转换后的值
        dat = num * 3.3000/0x3FF;   //转为要求的数据格式
        Uart_Printf("%.2f\n",dat);  //输出在串口
        uart_sendbyte(dat);         //发送至电脑
    }            
}

/*******功能函数定义*******/

/**
@brief 串口初始化，参考串口实验
*/
void uart0_init(void)   
{
    rGPHCON=(rGPHCON&~(0xfff<<4))|(0xaaa<<4);  
    rGPHUP=rGPHUP|(0x7<<2);                          
    rUFCON0=0x0;                                      
    rUMCON0=0x0;                                      
    rULCON0=(rULCON0&~0xff)|((0x0<<6)|(0x0<<3)|(0x0<<2)|(0x3));
    rUCON0=(rUCON0&~0x3ff)|((0x0<<10)|(0x0<<6)|(0x1<<2)|(0x1));
    // 波特率115200
    rUBRDIV0=(int)(50000000/(16*115200))-1;     
}

/**
@brief 串口发送数据，参考串口实验，但要注意数据类型为float
@param data 待发送的数据
*/
void uart_sendbyte(float data) 
{
    while(!(rUTRSTAT0&0x02));            
    rUTXH0=data;                                      
}

/**
@brief AD转换初始化
@param ch 选择的通道号
*/
void AD_Init(unsigned char ch) // ch不大于7，也就是说ch最多3位           
{
  rADCDLY=100;//设置ADC启动或间隔延时  P296 ADC起始延时寄存器
  rADCTSC=0;// 选择正常ADC模式，非触摸屏
  // ADCCON-ADC控制寄存器-PPT 297
  // 0 1 00110001 ccc000
  // ECFLG -> 一个只读引脚写入无效 PRSCEN -> 1 -> 分频器使能
  // SEL_MUX -> ch=ccc -> 模拟输入通道选择 
  // STDBM=0 -> 正常工作模式 
  // READ_START=0 -> 停止通过读取启动转换
  // ENABLE_START=0 -> 关闭AD转换器
  rADCCON=(1<<14)|(49<<6)|(ch<<3)|(0<<2)|(0<<1)|(0);
}

/**
@brief 取AD转换的值，这部分可直接参考PPT
@param ch 选择的通道号
*/
int Get_AD(unsigned char ch)   //取A/D转换的值
{
  int i;
  int val=0;
  if(ch>7) return 0; // 通道号不允许大于7
  for(i=0;i<16;i++) //为转换准确，转换16次
  {
    rADCCON|=0x1;   //启动A/D转换, 即设置ENABLE_START=1
    // 0xFFC7=1 1 11111111 000111 相当于清空ch的三位（清空SEL_MUX）
    // 和(ch<<3)的按位或操作在给SEL_MUX重新赋值
    rADCCON= rADCCON & 0xFFC7|(ch<<3); //选择A/D通道
    // 当ADDCON的最低位为1时执行循环体(因为在AD转换启动后ENABLE_START会被清零)
    while( rADCCON & 0x1);        //等待A/D转换开始
    // 当ADDCON的最高位不为1时执行循环体(因为最高位ECFLG指示结束转换标志, 转换结束, ECFLG=1)
    while(!(rADCCON & 0x8000));   //等待A/D转换结束
    // 0x03FF=0000 0011 1111 1111 读取ADCDATAn的0~9位（即数据）
    val=val+(rADCDAT0 & 0x03ff);  //取值 PPT 299
    Delay(10);
  }
  return(val>>4);  // 右移4位相当于除以16，返回每次转换均值
}
```

## 9 DMA 和中断技术

#### 9.1 DMA 技术的作用
 * 如果不采用 DMA 传输技术，而仅采用传统的 I/O 口传输，则一般需要 CPU 作为中介。CPU 的执行速度限定了传送的最大的速度（约为几十 kb/s）, 同时占用 CPU 的工作时间；而采用 DMA 传输，可以使外设直接与存储进行数据交换，CPU 放弃总线控制权，不再担当数据传输的中介，**提高传输速度且不再占用 CPU 的时间**；
 * 进行 DMA 传输时，CPU 可以去干其他事情。

#### 9.2 DMA 的优点

数据传输不需要占用 CPU，由 DMA 硬件来控制，数据直接在内存外设之间交换，可以达到很高的传输速率（可达几 MB/秒）

#### 9.3 DMA 的流程

![[Pasted image 20230314170544.png|475]]

1. 外设向 DMAC 发出请求；
2. DMAC 通过 HOLD 向 CPU 发出总线请求；
3. CPU 响应释放三总线，并且发应答 HLDA；
4. DMAC 向外设发 DMA 应答；
5. DMAC 发出地址、控制信号，为外设传送数据；
6. 传送完规定的数据后，DMAC 撤销 HOLD 信号，CPU 也撤销 HLDA 信号，并且恢复对三总线的控制。

#### 9.4 中断的定义

CPU 执行程序时，由于发生了某种随机的事件 (外部或内部)，引起 CPU 暂时**中断正在运行的程序**，转去**执行一段特殊的服务程序** (称为中断服务程序或中断处理程序)，以处理该事件，该事件处理完后又**返回**被中断的程序**继续执行**，这一过程称为中断。

#### 9.4 中断的过程

* **中断请求**：中断源提供中断请求；
* **中断判优**：根据仲裁器判断各个中断的优先级；
* **中断响应**：若发出请求的中断源之前没有优先级更高的中断发出请求，则开始中断响应；
* **中断服务**：保护现场之后，程序跳转到中断向量对应的入口地址，执行中断服务；
* **中断返回**：中断服务程序执行完毕后，最终会根据之前保护的现场返回之前程序的运行状态。
 
#### 9.5 一个押题

**DMA 传送流程，此过程的理解。**
外设直接与存储器进行数据交换，CPU放弃总线控制权，不再担当数据传输的中介者，总线由DMA控制器（DMAC）掌管，内存/外设的地址和控制信号由DMAC提供，所以在进行DMA传输时，CPU可以去做其它事。  
**DMA 主要优点**：可以不通过 CPU 的中断来实现数据的传输，DMA 的运行可以通过软件或者通过外围设备的中断和请求来初始化。  
**中断**：CPU执行程序时，由于发生了某种随机的事件（外部或内部），引起CPU暂时中断正在运行的程序，转去执行一段特殊的服务程序（称为中断服务程序或中断处理程序），以处理该事件，该事件处理完后又返回被中断的程序继续执行，这一过程称为中断。  
**中断过程**：中断请求-中断判优（有时还要进行中断源识别）-中断响应-中断服务-中断返回。