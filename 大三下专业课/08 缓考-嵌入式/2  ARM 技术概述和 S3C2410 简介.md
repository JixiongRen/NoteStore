#### 2.1 精简指令集（RISC）与 CISC 的区别 

| __指标__ | **RSIC** | **CISC** |
| :--------: | :--------: | :--------: |
| 指令集   |一个周期执行一条指令，简单指令组成复杂操作，指令长度固定|指令长度不固定，执行需多个周期|
| 流水线   |流水线每周期前进一步|指令的执行需要调用微代码的一个微程序|
| 寄存器   |更多用于通用寄存器|用于专用寄存器|
|Load/Store 结构|独立的 Load/Store 指令完成数据在寄存器内外的传输|处理器直接处理存储器数据|


#### 2.2 存储器大小端模式的区别 

* 大端：大端的数据存放格式是指将最高有效字节置于最低位地址 
![[Pasted image 20230208201816.png|200]]
* 小端：小端的数据存放格式是指将最高有效字节于最高位地址
 ![[Pasted image 20230208201837.png|200]]

#### 2.3 处理器的 7 种模式 

| **处理器模式** |                **说明**                |               **备注**               |
|:--------------:|:--------------------------------------:|:------------------------------------:|
|  用户（usr）   |            正常程序执行模式            |          不可切换至其他模式          |
|  系统 （sys）  |         运行操作系统的特权任务         | 与用户模式类似，但拥有切换模式的特权 |
| 快中断（fiq）  |       支持高速数据传输及通道处理       |       fiq 异常响应时进入此模式       |
|  中断（irq）   |            用于通用中断处理            |       irq 响应异常时进入此模式       |
|  管理（svc）   |            操作系统保护模式            |  系统复位和软件中断响应时进入此模式  |
|  中止（abt）   | 预期终止时进入，用于虚拟存储和存储保护 |        在 ARM7TDMI 没有大用处        |
| 未定义（und）  |        支持硬件协处理的软件仿真        |      未定义指令异常时进入此模式      |

> 除 ***用户模式（usr 模式）*** 外均为 ***特权模式***

>除 ***用户模式*** 与 ***系统模式*** 外均为 ***异常模式***

#### 2.4  流水线 
流水线是指程序执行多条指令重叠时的一种标准并行处理实现技术。各种部件同时处理是针对不同的指令而言的，他们可以同时为多条指令的不同部分进行工作，以提高各部件的利用率与指令的平均执行速度。

> 流水线分类 
>> 三级流水线 ARM 组织：**取指令→译码→执行；**
>> 五级流水线 ARM 组织：**取指令→译码→执行→缓冲/数据→回写；**
>> 六级流水线 ARM 组织：**取指令→发射→译码→执行→存储→回写。**

#### 2.4  实验二：存储器访问实验 
>编写程序，首先将 SDRAM 中 0x3300_0000 到 0x3300_FFFF 的内存空间中数据置为 0x55，然后将 Flash 中起始地址为 0x0000_0000 到 0x0000_FFFF 的数据拷贝到 SDRAM 中 0x3300_0000 到 0x3300_FFFF 的空间中。

```C
#include "def.h"
#include "option.h"
#include "2440addr.h"    
#include "2440lib.h"
#include "2440slib.h"  
#define UINT32T unsigned int  

int main(int argc,char **argv)
{
    UINT32T data;
    UINT32T *pt;    
    UINT32T *bt;
    bt=(UINT32T *)(0x33000000);//起始地址
    //给SDRAM中0x33000000到0x3300FFFF数值赋为0x55
    while((UINT32T)bt<=(0x3300FFFF))
    {
    *bt=0x55; //将0x55赋给指向SDRAM中的指针所在位置
    bt++;
    }
    pt=(UINT32T *)(0x00000000);//重定义pt起始地址
    bt=(UINT32T *)(0x33000000);//重定义bt的起始地址
    while((UINT32T)pt<=(0x0000FFFF))
    {
        data=*pt;//pt指向地址中的值赋给data
        *bt=data;//data赋给指向SDRAM中的指针bt指向的地址
        pt++;
        bt++;
    }
    while(1);
}
```

