#### 7.1  数据格式（帧格式）

|  **类型**  | **长度** |     **说明**     |
|:----------:|:--------:|:----------------:|
|   起始位   |   1 位   |   规定为低电平   |
|   数据位   |  5~8 位  | 要传送的有效信息 |
| 奇偶校验位 |   1 位   |        ——        |
|   停止位   |  1~2 位  |   规定为高电平   |

![[Pasted image 20230211202101.png]]

#### 7.2  三种校验方式对比

|  **方式名称**  |                                                                        **原理**                                                                        |                                      **特点**                                       |
|:--------------:|:------------------------------------------------------------------------------------------------------------------------------------------------------:|:-----------------------------------------------------------------------------------:|
|   奇偶校验位   |                                     在传送的字符之外再传送一位奇/偶校验位。可采用奇校验（1 的个数为奇数）或偶校验                                      |                              容易漏判错误，且不能纠错                               |
|   累加和校验   | 发送方将所发送的数据块求和，并将“校验和”附加到数据末尾，接收方也对接收到的数据求和，并将结果与发送方的“校验和”进行比较。一致则传输正确。反之传输错误。 |                             无法检验出字节或位序的错误                              |
| 循环冗余码校验 |                            块看成一串二进制数，再除以特定的数，将余数作为校验码发送到接收方。接收方同样求余，以校验是否出错                            | 目前该算法已广泛运用于数据存储和数据通信，并形成国际规范，市面上已有诸多 CRC 软件算法 |                                                                                                                                                        |                                                                                     |

#### 7.3  RS-232C 的电气特性
* IA 电平，高电平为+3~+15V，低电平为-15~-3V
* 实际应用中，常采用±12V
* RS-232C 的数据线 TXD、RXD 使用负逻辑，高电平表示 0，低电平表示 1

#### 7.3 实验四： 串口编程
>编写程序，控制实验平台的 UART1（波特率 38400、1 位停止位、无校验位），接收 PC 机上 windows 自带的超级终端串口通信程序发送的字符，同时按照以下要求将相应的字符返回给 PC 机的超级终端串口通信程序显示。
>>如 PC 机发送“A”，则返回字符“1” 
>>如 PC 机发送“B”，则返回字符“2”
>>如 PC 机发送“C”，则返回字符“3”
>>如 PC 机发送其他字符，则返回字符“4”

```C
#include "def.h"
#include "option.h"
#include "2440addr.h"    
#include "2440lib.h"
#include "2440slib.h"    
#define UINT32T unsigned int

// 函数声明
void uart1_init(void); //串口初始化函数
void uart_sendbyte(char data); //发送函数
char uart_getch(void); //接收字符

void main(int argc,char **argv)
{
    uart0_init(); //先初始化串口   
    while(1)
    {
        uart_getch(); //读取字符
        switch(rURXH0) 
        {
	        //接收A,发送1
            case 'A':uart_sendbyte('1');break; 
            //接收B,发送2
            case 'B':uart_sendbyte('2');break; 
            //接收C,发送3
            case 'C':uart_sendbyte('3');break; 
            //接收D,发送4
            default: uart_sendbyte('4');break; 
         }
    }
}

/**
@brief 串口初始化
*/
void uart1_init(void)                    
{
	rGPHCON=(rGPHCON&~(0xfff<<4))|(0xaaa<<4);
	//设置端口RX0~2、TX0~2
    rGPHUP=rGPHUP|(0x7<<2);  //禁止GPH1~3上拉
    rUFCON1=0x0;             //禁止FIFO
    rUMCON1=0x0;             //禁止AFC    
    // ULCON1 < - 0 0 000 0 11
    // 0-保留位 0-正常模式 000-无校验 0-1个停止位 11-数据位8bit
    rULCON1=(rULCON1&~0xff)|((0x0<<6)|(0x0<<3)|(0x0<<2)|(0x3));
    // UCON1 < - 1 0 0 0 0 0 0 01 01
    // 1-ULK作比特率发生器 0-tx中断脉冲触发 0-接收超时中断不允许
    // 0-不产生接收错误中断 0-正常模式 0-正常模式发送
    // 01-发送模式为中断或查询模式 01-接受模式为中断或查询模式
    rUCON1=(rUCON1&~0x3ff)|((0x0<<10)|(0x0<<6)|(0x1<<2)|(0x1));
    rUBRDIV1=(int)(50000000/(16*38400)-1); //设置波特率38400  
}

/**
@brief 通过串口发送字符
@param data 待发送的字符
*/
void uart_sendbyte(char data)    
{
	// 在关闭FIFO的情况下，UTRSRTAT[1]=1 - > 发送缓冲为空，已发完
    while(!(rUTRSTAT1&0x02));  //判断是否发完
    rUTXH1=data; // 将数据送入缓冲区
}

/**
@brief 从串口读取数据
*/
char uart_getch(void)                  
{
	// 在关闭FIFO的情况下，UTRSRTAT[0]=0 - > 接收缓冲为空，已收完
    while(!(rUTRSTAT1&0x01));  //不为空的时候读出
    return rURXH1; // 将数据提出缓冲区
}
```